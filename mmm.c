#include <stdlib.h>
#include <time.h>
#include <math.h>
#include <string.h>
#include <stdio.h>
#include "mmm.h"

/**
 * Allocate and initialize the matrices on the heap. Populate
 * the input matrices with random numbers from 0 to 99
 */
void mmm_init() {
	// TODO
	// A = (double **) malloc(size * sizeof(double*));
	// allocate the rest of the matrices
	 // malloc a size N array of pointers to ints
 	A = (double**) malloc(sizeof(double*) * size);
	B = (double**) malloc(sizeof(double*) * size);
	SEQ_MATRIX = (double**) malloc(sizeof(double*) * size);
	if(mode == 2) PAR_MATRIX = (double**) malloc(sizeof(double*) * size);
	//printf("Allocated space for matrices\n");

 	// iterate through each row and malloc a size N array of ints
 	for (int i = 0; i < size; i++) {
    	A[i] = (double*) malloc(sizeof(double) * size);
		B[i] = (double*) malloc(sizeof(double) * size);
		SEQ_MATRIX[i] = (double*) malloc(sizeof(double) * size);
		if(mode == 2) PAR_MATRIX[i] = (double*) malloc(sizeof(double) * size);
 	}
	//printf("Allocated columns for matrices\n");
 	// can now have access to matrix[i][j]
	// TODO
	srand((unsigned)time(NULL));	// seed the random number generator
 	// initialize A and B with random values between 0 and 99
	// initialize SEQ_MATRIX and PAR_MATRIX with 0s
	for(int i = 0; i < size; i++) { // initialize matrix with random values
		for(int j = 0; j < size; j++) {
			double r = rand() % 100;
			A[i][j] = r;
			//printf("Allocated A at %d %d with value %.1f\n", i, j, r);
			r = rand() % 100;
			B[i][j] = r;
			//printf("Allocated B at %d %d with value %.1f\n", i, j, r);
			SEQ_MATRIX[i][j] = 0;
			//printf("Allocated seq matrix to 0\n");
			if(mode == 2) {
				PAR_MATRIX[i][j] = 0;
				//printf("Allocated par matrix to 0\n");
			}
		}
	}

}

/**
 * Reset a given matrix to zeroes (their size is in the global var)
 * @param matrix pointer to a 2D array
 */
void mmm_reset(double **matrix) {
	for(int i = 0; i < size; i++) {
		for(int j = 0; j < size; j++) {
			matrix[i][j] = 0;
		}
	}
}

/**
 * Free up memory allocated to all matrices
 * (their size is in the global var)
 */
void mmm_freeup() {
	// TODO
	for(int i = 0; i < size; i++) {
		free(A[i]);
		free(B[i]);
		free(SEQ_MATRIX[i]);
		if(mode == 2) free(PAR_MATRIX[i]);
	}
	free(A);
	free(B);
	free(SEQ_MATRIX);
	if(mode == 2) free(PAR_MATRIX);
}

/**
 * Sequential MMM (size is in the global var)
 */
void mmm_seq() {
	for(int i = 0; i < size; i++) {
		for(int j = 0; j < size; j++) {
			for(int k = 0; k < size; k++) {
				SEQ_MATRIX[i][j] += A[i][k] * B [k][j];
			}
		}
	}
}

/**
 * Parallel MMM
 */
void *mmm_par(void *args) {
	// TODO - code to perform parallel MMM
	int *range = (int*) args;
	int end = *range + (size / num_threads);
	if(end > size) end = size;
	for(int i = *range; i < end; i++) {
		for(int j = 0; j < size; j++) {
			for(int k = 0; k < size; k++) {
				PAR_MATRIX[i][j] += A[i][k] * B [k][j];
			}
		}
	}
	return NULL;
}

/**
 * Verifies the correctness between the matrices generated by
 * the sequential run and the parallel run.
 *
 * @return the largest error between two corresponding elements
 * in the result matrices
 */
double mmm_verify() {
	// TODO
	// You may find the math.h function fabs() to be useful here (absolute value)
	double difference = 0;
	for(int i = 0; i < size; i++) {
		for(int j = 0; j < size; j++) {
			difference += fabs(SEQ_MATRIX[i][j] - PAR_MATRIX[i][j]);
		}
	}
	return difference;
}

void display() {
	for(int i = 0; i < size; i++) {
		printf("\n");
		for(int j = 0; j < size; j++) {
			if(mode == 1) printf("%.1f ", SEQ_MATRIX[i][j]);
			if(mode == 2) printf("%.1f ", PAR_MATRIX[i][j]);
		}
	}
	printf("\n");
}
